@using PubNet.API.DTO
@inject ApiClient Http
@inject PackagesService Packages
@inject AnalysisService Analysis
@inject ILogger<AnalysisBadges> Logger

<div style="display: flex; align-items: center; gap: 0.25rem">
	@if (Mirrored)
	{
		<a href="@("https://pub.dev/packages/" + PackageName)" target="_blank">
			<div class="badge bg-secondary">Mirrored from pub.dev</div>
		</a>
	}

	@if (AnalysisDto?.DocumentationHref is not null)
	{
		<NavLink href="@(DocumentationUrl(AnalysisDto.DocumentationHref))" class="badge bg-info">Docs</NavLink>
	}

	@if (AnalysisDto?.Formatted == true)
	{
		<div class="badge bg-success">Formatted</div>
	}
	else if (AnalysisDto?.Formatted == false)
	{
		<div class="badge bg-warning">Not Formatted</div>
	}
	else if (PackageVersionDto is not null)
	{
		<div class="badge bg-secondary">Not analyzed</div>
	}

	@if (IsDiscontinued)
	{
		<div class="badge bg-danger">Discontinued</div>

		@if (ReplacedBy is not null)
		{
			<NavLink href="@(HrefToReplacement(ReplacedBy))" class="badge bg-warning">Replaced by <code>@ReplacedBy</code></NavLink>
		}
	}

	@if (Retracted)
	{
		<div class="badge bg-danger">Retracted</div>
	}
</div>

@code {

	[Parameter]
	public string? PackageName { get; set; }

	[Parameter]
	public string? PackageVersion { get; set; }

	private PackageVersionAnalysisDto? AnalysisDto { get; set; }

	private PackageVersionDto? PackageVersionDto { get; set; }

	private PackageDto? PackageDto { get; set; }

	private bool Mirrored => PackageDto?.Mirrored ?? false;

	private bool IsDiscontinued => PackageDto?.IsDiscontinued ?? false;

	private string? ReplacedBy => PackageDto?.ReplacedBy;

	private bool Retracted => PackageVersionDto?.Retracted ?? false;

	private static string HrefToReplacement(string name) => "/packages/" + name;

	private string DocumentationUrl(string uri) => Http.BaseAddress!.TrimEnd('/') + '/' + uri.TrimStart('/');

	/// <inheritdoc />
	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		if (PackageName is null || PackageVersion is null) return;

		PackageDto = await Packages.GetPackage(PackageName, false);

		if (!(PackageDto?.Mirrored ?? false))
		{
			PackageVersionDto = await Packages.GetPackageVersion(PackageName, PackageVersion);
			AnalysisDto = await Analysis.GetAnalysisForVersion(PackageName, PackageVersion, false);
		}
	}

}
