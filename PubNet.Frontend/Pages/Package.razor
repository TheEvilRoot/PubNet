@page "/package/{PackageName}"
@page "/packages/{PackageName}"
@using PubNet.API.DTO
@using System.Net
@using Markdig;

@inject ApiClient Http
@inject AuthenticationService Auth
@inject NavigationManager Nav
@inject AlertService Alert
@inject PackagesService Packages
@inject AnalysisService Analysis

@if (Error is not null)
{
	<div class="alert alert-danger">
		<strong>Whoops!</strong> @Error
	</div>

	@if (ShowUpstreamLink)
	{
		<p>
			Maybe you can find this package at pub.dev instead: <a href="@("https://pub.dev/packages/" + PackageName)">pub.dev/packages/@PackageName</a>
		</p>
	}
}

@if (Info is not null)
{
	<div class="alert alert-info">
		@Info
	</div>
}

@if (PackageModel is null && Error is null)
{
	<PageTitle>@PackageName</PageTitle>

	<h1>
		<code>@PackageName</code>
	</h1>

	<p>
		<em>Loading...</em>
	</p>
}
else if (PackageModel is not null)
{
	@if (PackageModel.Latest is not { } titleLatest)
	{
		<PageTitle>@PackageName</PageTitle>

		<h1>
			<code>@PackageName</code>
		</h1>

		<p>
			Published by <AuthorLink Username="@PackageModel.Author?.UserName"/>
		</p>
	}
	else
	{
		<PageTitle>@PackageName: @titleLatest.Version</PageTitle>

		<h1>
			<code>@PackageName: @titleLatest.Version</code>

			<ClickToCopyButton Content="@PubspecVersionText(titleLatest.Version, PackageModel.Mirrored)"/>
		</h1>

		<p class="text-muted">
			Published by <AuthorLink Username="@PackageModel.Author?.UserName"/> <abbr title="@titleLatest.Published">@(titleLatest.Published.Humanize())</abbr>
		</p>
	}

	@if (ShowPackageAdminTools)
	{
		<div style="display: flex; align-items: center; gap: 0.25rem" class="my-3">
			@if (!PackageModel.IsDiscontinued)
			{
				<button class="btn btn-sm btn-outline-warning" @onclick="OnDiscontinueClicked" disabled="@Editing">Discontinue</button>
			}
			<button class="btn btn-sm btn-outline-danger" @onclick="OnDeleteClicked" disabled="@Editing">Delete</button>
		</div>
	}

	<AnalysisBadges PackageName="@PackageName" PackageVersion="@PackageModel?.Latest?.Version" />

	@if (PackageModel?.Latest is {} latest)
	{
		<p class="my-3 lead">@(latest.PubSpec.Description)</p>

		<div class="row">
			<div class="col-12 col-sm-6">
				<h2 class="mt-4">Dependencies</h2>

				@if (latest.PubSpec.Dependencies is null or { Count: 0 })
				{
					<p class="my-3">
						<em>No dependencies.</em>
					</p>
				}
				else
				{
					<ul>
						@foreach (var dependency in latest.PubSpec.Dependencies)
						{
							<li>
								<NavLink href="@HrefToDependency(dependency.Key)">@dependency.Key</NavLink>
							</li>
						}
					</ul>
				}
			</div>
			<div class="col-12 col-sm-6">
				<h2 class="mt-4">Dev Dependencies</h2>

				@if (latest.PubSpec.DevDependencies is null or { Count: 0 })
				{
					<p class="my-3">
						<em>No dependencies.</em>
					</p>
				}
				else
				{
					<ul>
						@foreach (var dependency in latest.PubSpec.DevDependencies)
						{
							<li>
								<NavLink href="@HrefToDependency(dependency.Key)">@dependency.Key</NavLink>
							</li>
						}
					</ul>
				}
			</div>
		</div>

		@if (LatestVersionAnalysis is not { ReadmeText: null })
		{
			<div class="my-3">
				@((MarkupString) Markdown.ToHtml(ReadmeText, MarkdownPipeline))
			</div>
		}
	}

	@if (PackageModel?.Versions is not null)
	{
		<h2 class="my-3">Versions</h2>

		<table class="table">
			<thead>
			<tr>
				<th>Version</th>
				<th>Published At</th>
				@if (!IsMirrored)
				{
					<th>Badges</th>
				}
				@if (ShowPackageAdminTools)
				{
					<th>Actions</th>
				}
			</tr>
			</thead>
			<tbody>
			@foreach (var version in PackageModel.Versions.OrderByDescending(v => v.Published).Take(10))
			{
				<tr>
					<td>
						<code>@version.Version</code>

						<ClickToCopyButton Content="@(PubspecVersionText(version.Version, IsMirrored))"/>
					</td>
					<td>
						<abbr title="@version.Published">@(version.Published.Humanize())</abbr>
					</td>
					@if (!IsMirrored)
					{
						<td>
							<AnalysisBadges PackageName="@PackageName" PackageVersion="@version.Version" />
						</td>
					}
					@if (ShowPackageAdminTools)
					{
						<td>
							<div style="display: flex; align-items: center; gap: 0.25rem">
								@if (!version.Retracted)
								{
									<button class="btn btn-sm btn-outline-warning" @onclick="() => OnRetractVersionClicked(version.Version)" disabled="@Editing">Retract</button>
								}
								<button class="btn btn-sm btn-outline-danger" @onclick="() => OnDeleteVersionClicked(version.Version)" disabled="@Editing">Delete</button>
							</div>
						</td>
					}
				</tr>
			}

			@if (PackageModel.Versions.Count() > 10)
			{
				<tr>
					<td colspan="3">
						<span class="text-muted">... and @(PackageModel.Versions.Count() - 10) older versions</span>
					</td>
				</tr>
			}
			</tbody>
		</table>
	}
	else
	{
		<p class="my-3">
			<em>No versions found.</em>
		</p>
	}
}

@code
{
	[Parameter]
	public string? PackageName { get; set; }

	private PackageDto? PackageModel { get; set; }
	private PackageVersionAnalysisDto? LatestVersionAnalysis { get; set; }

	private string? Error { get; set; }
	private string? Info { get; set; }

	private bool Editing { get; set; }
	private bool ShowPackageAdminTools { get; set; }
	private bool ShowUpstreamLink { get; set; }

	private static string HrefToDependency(string name) => "/package/" + name;

	private string ReadmeText => LatestVersionAnalysis?.ReadmeText ?? string.Empty;

	private MarkdownPipeline MarkdownPipeline => new MarkdownPipelineBuilder()
		.UseAdvancedExtensions()
		.Build();

	private string PubspecVersionText(string version, bool mirrored)
	{
		if (mirrored)
			return $"{PackageName}: ^{version}";

		return $@"{PackageName}:
  hosted:
    url: {Http.BaseAddress}
    name: {PackageName}
    version: ^{version}";
	}

	private bool IsMirrored => PackageModel?.Mirrored ?? false;

	protected override async Task OnParametersSetAsync()
	{
		await base.OnParametersSetAsync();

		await ReloadPackage();
	}

	private async Task ReloadPackage() {
		Error = null;
		PackageModel = null;
		LatestVersionAnalysis = null;
		Editing = false;
		ShowPackageAdminTools = false;
		ShowUpstreamLink = false;

		if (PackageName is null)
			return;

		try
		{
			PackageModel = await Packages.GetPackage(PackageName, true, true);
		}
		catch (PackageNotFoundException pnfe)
		{
			Error = pnfe.Message;
			ShowUpstreamLink = true;
		}
		catch (Exception e)
		{
			Error = e.Message;
		}

#pragma warning disable CS4014
		if (PackageModel?.Latest is not null)
			Analysis.GetAnalysisForVersion(PackageName, PackageModel.Latest.Version, true)
				.ContinueWith(task =>
				{
					if (task.IsFaulted)
					{
						Error = task.Exception!.Message;
					}
					else
					{
						LatestVersionAnalysis = task.Result;
					}
				});

		if (PackageModel?.Versions is not null)
			Task.WhenAll(PackageModel.Versions.Select(v => Analysis.GetAnalysisForVersion(PackageName, v.Version, false))).ContinueWith(_ => StateHasChanged());
#pragma warning restore CS4014

		ShowPackageAdminTools = await Auth.IsSelf(PackageModel?.Author?.UserName);
	}

	private async Task OnDeleteClicked()
	{
		var confirmed = await Alert.Confirm("Are you sure? All versions will be deleted and you can no longer 'pub get' it.");
		if (!confirmed)
			return;

		Error = null;
		Editing = true;

		try
		{
			await Packages.DeletePackage(PackageName!);

			Nav.NavigateTo("/?message=package-deleted");
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnDeleteVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to delete {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			await Packages.DeletePackageVersion(PackageName!, version);

			Info = $"Version {version} has been deleted.";

			await ReloadPackage();
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnDiscontinueClicked()
	{
		var replacement = await Alert.Prompt($"Are you sure you want to discontinue {PackageName}? This change cannot be undone.\r\n\r\nYou can suggest a replacement package here:");
		if (replacement is null)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			await Packages.DiscontinuePackage(PackageName!, replacement);

			Info = $"Package {PackageName} has been marked as discontinued.";

			await ReloadPackage();
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnRetractVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to retract {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			await Packages.RetractVersion(PackageName!, version);

			Info = $"Package version {version} has been marked as retracted.";

			await ReloadPackage();
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}
}
