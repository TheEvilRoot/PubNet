@page "/package/{PackageName}"
@using PubNet.API.DTO
@using System.Net

@inject ApiClient Http
@inject AuthenticationService Auth
@inject NavigationManager Nav
@inject AlertService Alert

@if (Error is not null)
{
	<div class="alert alert-danger">
		<strong>Whoops!</strong> @Error
	</div>

	@if (ShowUpstreamLink)
	{
		<p>
			Maybe you can find this package at pub.dev instead: <a href="@("https://pub.dev/packages/" + PackageName)">pub.dev/packages/@PackageName</a>
		</p>
	}
}

@if (Info is not null)
{
	<div class="alert alert-info">
		@Info
	</div>
}

@if (PackageModel is null && Error is null)
{
	<PageTitle>@PackageName</PageTitle>

	<h1>
		<code>@PackageName</code>
	</h1>

	<p>
		<em>Loading...</em>
	</p>
}
else if (PackageModel is not null)
{
	@if (PackageModel.Latest is not { } titleLatest)
	{
		<PageTitle>@PackageName</PageTitle>

		<h1>
			<code>@PackageName</code>
		</h1>

		<p>
			Published by <AuthorLink Username="@PackageModel.Author?.UserName"/>
		</p>
	}
	else
	{
		<PageTitle>@PackageName: @titleLatest.Version</PageTitle>

		<h1>
			<code>@PackageName: @titleLatest.Version</code>

			<ClickToCopyButton Content="@PubspecVersionText(titleLatest.Version, PackageModel.Mirrored)"/>
		</h1>

		<p class="text-muted">
			Published by <AuthorLink Username="@PackageModel.Author?.UserName"/> <abbr title="@titleLatest.Published">@(titleLatest.Published.Humanize())</abbr>
		</p>
	}

	@if (ShowPackageAdminTools)
	{
		<div style="display: flex; align-items: center; gap: 0.25rem" class="my-3">
			@if (!PackageModel.IsDiscontinued)
			{
				<button class="btn btn-sm btn-outline-warning" @onclick="OnDiscontinueClicked" disabled="@Editing">Discontinue</button>
			}
			<button class="btn btn-sm btn-outline-danger" @onclick="OnDeleteClicked" disabled="@Editing">Delete</button>
		</div>
	}

	<AnalysisBadges ShowAnlysis="@(PackageModel.Latest is not null && !PackageModel.Mirrored)" Analysis="PackageModel.Latest?.Analysis" Mirrored="PackageModel.Mirrored" PackageName="@PackageName" IsDiscontinued="@PackageModel.IsDiscontinued" ReplacedBy="@PackageModel.ReplacedBy" />

	@if (PackageModel.Latest is {} latest)
	{
		<p class="my-3 lead">@(latest.PubSpec.Description)</p>

		<div class="row">
			<div class="col-12 col-sm-6">
				<h2 class="mt-4">Dependencies</h2>

				@if (latest.PubSpec.Dependencies is null or { Count: 0 })
				{
					<p class="my-3">
						<em>No dependencies.</em>
					</p>
				}
				else
				{
					<ul>
						@foreach (var dependency in latest.PubSpec.Dependencies)
						{
							<li>
								<NavLink href="@HrefToDependency(dependency.Key)">@dependency.Key</NavLink>
							</li>
						}
					</ul>
				}
			</div>
			<div class="col-12 col-sm-6">
				<h2 class="mt-4">Dev Dependencies</h2>

				@if (latest.PubSpec.DevDependencies is null or { Count: 0 })
				{
					<p class="my-3">
						<em>No dependencies.</em>
					</p>
				}
				else
				{
					<ul>
						@foreach (var dependency in latest.PubSpec.DevDependencies)
						{
							<li>
								<NavLink href="@HrefToDependency(dependency.Key)">@dependency.Key</NavLink>
							</li>
						}
					</ul>
				}
			</div>
		</div>
	}

	@if (PackageModel.Versions is not null)
	{
		<h2 class="my-3">Versions</h2>

		<table class="table">
			<thead>
			<tr>
				<th>Version</th>
				<th>Published At</th>
				@if (!IsMirrored)
				{
					<th>Badges</th>
				}
				@if (ShowPackageAdminTools)
				{
					<th>Actions</th>
				}
			</tr>
			</thead>
			<tbody>
			@foreach (var version in PackageModel.Versions.OrderByDescending(v => v.Published).Take(10))
			{
				<tr>
					<td>
						<code>@version.Version</code>

						<ClickToCopyButton Content="@(PubspecVersionText(version.Version, IsMirrored))"/>
					</td>
					<td>
						<abbr title="@version.Published">@(version.Published.Humanize())</abbr>
					</td>
					@if (!IsMirrored)
					{
						<td>
							<AnalysisBadges Analysis="@version.Analysis" Retracted="@version.Retracted" />
						</td>
					}
					@if (ShowPackageAdminTools)
					{
						<td>
							<div style="display: flex; align-items: center; gap: 0.25rem">
								@if (!version.Retracted)
								{
									<button class="btn btn-sm btn-outline-warning" @onclick="() => OnRetractVersionClicked(version.Version)" disabled="@Editing">Retract</button>
								}
								<button class="btn btn-sm btn-outline-danger" @onclick="() => OnDeleteVersionClicked(version.Version)" disabled="@Editing">Delete</button>
							</div>
						</td>
					}
				</tr>
			}

			@if (PackageModel.Versions.Count() > 10)
			{
				<tr>
					<td colspan="3">
						<span class="text-muted">... and @(PackageModel.Versions.Count() - 10) older versions</span>
					</td>
				</tr>
			}
			</tbody>
		</table>
	}
	else
	{
		<p class="my-3">
			<em>No versions found.</em>
		</p>
	}
}

@code
{
	[Parameter]
	public string? PackageName { get; set; }

	private PackageDto? PackageModel { get; set; }

	private string? Error { get; set; }
	private string? Info { get; set; }

	private bool Editing { get; set; }
	private bool ShowPackageAdminTools { get; set; }
	private bool ShowUpstreamLink { get; set; }

	private static string HrefToDependency(string name) => "/package/" + name;

	private string PubspecVersionText(string version, bool mirrored)
	{
		if (mirrored)
			return $"{PackageName}: ^{version}";

		return $@"{PackageName}:
  hosted:
    url: {Http.BaseAddress}
    name: {PackageName}
    version: ^{version}";
	}

	private bool IsMirrored => PackageModel?.Mirrored ?? false;

	protected override async Task OnParametersSetAsync()
	{
		await base.OnParametersSetAsync();

		await ReloadPackage();
	}

	private async Task ReloadPackage() {
		Error = null;
		PackageModel = null;
		Editing = false;
		ShowPackageAdminTools = false;
		ShowUpstreamLink = false;

		try
		{
			var response = await Http.GetAsync($"packages/{PackageName}?includeAuthor=true&includeAnalysis=true");
			if (response.IsSuccessStatusCode)
			{
				PackageModel = await response.Content.ReadFromJsonAsync<PackageDto>();
			}
			else
			{
				PackageModel = null;
				if (response.StatusCode == HttpStatusCode.NotFound)
				{
					Error = "The package you are looking for does not exist";
					ShowUpstreamLink = true;
				}
				else
				{
					Error = "An unknown error occurred";
				}
			}

			ShowPackageAdminTools = PackageModel?.Author?.UserName is not null
			                        && await Auth.IsSelf(PackageModel.Author.UserName);
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
	}

	private async Task OnDeleteClicked()
	{
		var confirmed = await Alert.Confirm("Are you sure? All versions will be deleted and you can no longer 'pub get' it.");
		if (!confirmed)
			return;

		Error = null;
		Editing = true;

		try
		{
			var response = await Http.DeleteAsync($"packages/{PackageName}");
			if (response.IsSuccessStatusCode)
			{
				Nav.NavigateTo("/?message=package-deleted");
			}
			else
			{
				Error = response.StatusCode switch {
					HttpStatusCode.Unauthorized => "You are not authorized to delete this package",
					HttpStatusCode.NotFound => "The package was not found",
					_ => "An unknown error occurred",
				};
			}
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnDeleteVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to delete {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			var response = await Http.DeleteAsync($"packages/{PackageName}/versions/{version}");
			if (response.IsSuccessStatusCode)
			{
				Info = $"Version {version} has been deleted.";

				await ReloadPackage();
			}
			else
			{
				Error = response.StatusCode switch {
					HttpStatusCode.Unauthorized => "You are not authorized to delete this package version",
					HttpStatusCode.NotFound => "This package version was not found",
					_ => "An unknown error occurred",
				};
			}
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnDiscontinueClicked()
	{
		var replacement = await Alert.Prompt($"Are you sure you want to discontinue {PackageName}? This change cannot be undone.\r\n\r\nYou can suggest a replacement package here:");
		if (replacement is null)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			var dto = new SetDiscontinuedDto(string.IsNullOrWhiteSpace(replacement) ? null : replacement);
			var response = await Http.PatchAsync($"packages/{PackageName}/discontinue", dto);
			if (response.IsSuccessStatusCode)
			{
				Info = $"Package {PackageName} has been marked as discontinued.";

				await ReloadPackage();
			}
			else
			{
				Error = response.StatusCode switch {
					HttpStatusCode.Unauthorized => "You are not authorized to discontinue this package",
					HttpStatusCode.NotFound => "This package was not found",
					_ => "An unknown error occurred",
				};
			}
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnRetractVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to retract {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			var response = await Http.PatchAsync($"packages/{PackageName}/versions/{version}/retract");
			if (response.IsSuccessStatusCode)
			{
				Info = $"Package version {version} has been marked as retracted.";

				await ReloadPackage();
			}
			else
			{
				Error = response.StatusCode switch {
					HttpStatusCode.Unauthorized => "You are not authorized to retract this package version",
					HttpStatusCode.NotFound => "This package version was not found",
					_ => "An unknown error occurred",
				};
			}
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}
}
