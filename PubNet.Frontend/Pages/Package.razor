@page "/package/{PackageName}"
@using System.Net
@inject ApiClient Http
@inject AuthenticationService Auth
@inject NavigationManager Nav

@if (Error is not null)
{
    <div class="alert alert-danger">
        <strong>Whoops!</strong> @Error
    </div>
}

@if (PackageModel is null && Error is null)
{
    <PageTitle>@PackageName</PageTitle>

    <h1>@PackageName</h1>

    <p>
        <em>Loading...</em>
    </p>
}
else if (PackageModel is not null)
{
    <PageTitle>@PackageName @(PackageModel.Latest?.Version)</PageTitle>

    <h1>@PackageName @(PackageModel.Latest?.Version)</h1>

    @if (ShowPackageAdminTools)
    {
        <button class="btn btn-outline-danger my-3" @onclick="OnDeleteClicked" disabled="@Editing">Delete</button>
    }

    <p>
        Published by @if (PackageModel.Author is not null)
                     {
                         <NavLink href="@("/author/" + PackageModel.Author.UserName)">@PackageModel.Author.UserName</NavLink>
                     }
                     else
                     {
                         <span class="text-muted">&lt;deleted&gt;</span>
                     }
    </p>

    <h2>Description</h2>

    <p>@(PackageModel.Latest?.PubSpec?.Description)</p>

    <h2>Dependencies</h2>

    @if (PackageModel.Latest?.PubSpec?.Dependencies is null || PackageModel.Latest?.PubSpec?.Dependencies.Count == 0)
    {
        <p><em>No dependencies.</em></p>
    }
    else
    {
        <ul>
            @foreach (var dependency in PackageModel.Latest!.PubSpec!.Dependencies!)
            {
                <li><NavLink href="@("/package/" + dependency.Key)">@dependency.Key</NavLink></li>
            }
        </ul>
    }

    <h2>Versions</h2>

    <table class="table">
        <thead>
        <tr>
            <th>Version</th>
            <th>Published At</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var version in PackageModel.Versions.OrderByDescending(v => v.PublishedAtUtc))
        {
            <tr>
                <td>@version.Version</td>
                <td>@version.PublishedAtUtc</td>
            </tr>
        }
        </tbody>
    </table>
}

@code
{
    [Parameter]
    public string? PackageName { get; set; }

    private Models.Package? PackageModel { get; set; }
    private string? Error { get; set; }
    
    private bool Editing { get; set; }
    private bool ShowPackageAdminTools { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        Error = null;

        try
        {
            var response = await Http.GetAsync($"packages/{PackageName}");
            if (response.IsSuccessStatusCode)
            {
                PackageModel = await response.Content.ReadFromJsonAsync<Models.Package>();
            }
            else
            {
                Error = response.StatusCode switch {
                    HttpStatusCode.NotFound => "The package you are looking for does not exist",
                    _ => "An unknown error occurred",
                };
            }

            ShowPackageAdminTools = PackageModel?.Author?.UserName is not null
                                    && await Auth.IsSelf(PackageModel.Author.UserName);
        }
        catch (Exception e)
        {
            Error = e.Message;
        }
    }

    private async Task OnDeleteClicked()
    {
        Error = null;
        Editing = true;

        try
        {
            var response = await Http.DeleteAsync($"packages/{PackageName}");
            if (response.IsSuccessStatusCode)
            {
                Nav.NavigateTo("/?message=package-deleted");
            }
            else
            {
                Error = response.StatusCode switch {
                    HttpStatusCode.Unauthorized => "You are not authorized to delete this package",
                    HttpStatusCode.NotFound => "The package was not found",
                    _ => "An unknown error occurred",
                };
            }
        }
        catch (Exception e)
        {
            Error = e.Message;
        }
        finally
        {
            Editing = false;
        }
    }
}
