@page "/package/{PackageName}"
@page "/packages/{PackageName}"
@page "/package/{PackageName}/version/{PackageVersionUrl}"
@page "/packages/{PackageName}/versions/{PackageVersionUrl}"

@using PubNet.API.DTO

@inject ApiClient Http
@inject AuthenticationService Auth
@inject AlertService Alert
@inject PackagesService Packages
@inject AnalysisService Analysis

@if (Error is not null)
{
	<div class="alert alert-danger">
		<strong>Whoops!</strong> @Error
	</div>

	@if (ShowUpstreamLink)
	{
		<p>
			Maybe you can find this package at pub.dev instead: <a href="@("https://pub.dev/packages/" + PackageName)">pub.dev/packages/@PackageName</a>
		</p>
	}
}

@if (Info is not null)
{
	<div class="alert alert-info">
		@Info
	</div>
}

@if (PackageModel is not null)
{
	<PackageVersionOverview
		Package="@PackageModel"
		Version="@PackageVersionModel"
		OnError="(e) => Error = e"
		OnInfo="(i) => Info = i"
		OnEditing="(e) => Editing = e"
		Editing="@Editing"
		OnPackageDiscontinued="ReloadPackage" />

	@if (PackageVersions is not null)
	{
		<h2 class="my-3">Versions</h2>

		<table class="table">
			<thead>
			<tr>
				<th>Version</th>
				<th>Published At</th>
				@if (!IsMirrored)
				{
					<th>Badges</th>
				}
				@if (ShowPackageAdminTools)
				{
					<th>Actions</th>
				}
			</tr>
			</thead>
			<tbody>
			@foreach (var version in PackageVersions.OrderByDescending(v => v.Published).Take(10))
			{
				<tr>
					<td>
						<NavLink href="@($"/packages/{PackageName}/versions/{TextGenerator.VersionToUrlSegment(version.Version)}")">
							<code>@version.Version</code>
						</NavLink>

						<ClickToCopyButton Content="@(PubspecVersionText(version.Version))"/>
					</td>
					<td>
						<abbr title="@version.Published">@(version.Published.Humanize())</abbr>
					</td>
					@if (!IsMirrored)
					{
						<td>
							<AnalysisBadges PackageDto="@PackageModel" PackageVersionDto="@version" />
						</td>
					}
					@if (ShowPackageAdminTools)
					{
						<td>
							<div style="display: flex; align-items: center; gap: 0.25rem">
								@if (!version.Retracted)
								{
									<button class="btn btn-sm btn-outline-warning" @onclick="() => OnRetractVersionClicked(version.Version)" disabled="@Editing">Retract</button>
								}
								<button class="btn btn-sm btn-outline-danger" @onclick="() => OnDeleteVersionClicked(version.Version)" disabled="@Editing">Delete</button>
							</div>
						</td>
					}
				</tr>
			}

			@if (PackageVersions.Count > 10)
			{
				<tr>
					<td colspan="3">
						<span class="text-muted">... and @(PackageVersions.Count - 10) older versions</span>
					</td>
				</tr>
			}
			</tbody>
		</table>
	}
	else
	{
		<p class="my-3">
			<em>No versions found.</em>
		</p>
	}
}

@code
{
	[Parameter]
	public string? PackageName { get; set; }

	[Parameter]
	public string? PackageVersionUrl { get; set; }

	private string? PackageVersion
	{
		get => PackageVersionUrl is null ? null : TextGenerator.UrlSegmentToVersion(PackageVersionUrl);
		set => PackageVersionUrl = value is null ? null : TextGenerator.VersionToUrlSegment(value);
	}

	private PackageDto? PackageModel { get; set; }

	private PackageVersionDto? PackageVersionModel { get; set; }

	private List<PackageVersionDto>? PackageVersions => PackageModel?.Versions;

	private string? Error { get; set; }

	private string? Info { get; set; }

	private bool Editing { get; set; }

	private bool ShowUpstreamLink { get; set; }

	private bool ShowPackageAdminTools { get; set; }

	private string PubspecVersionText(string version)
	{
		return PackageName is null
			? string.Empty
			: TextGenerator.PubspecVersionText(PackageName, version, IsMirrored, Http.BaseAddress);
	}

	private bool IsMirrored => PackageModel?.Mirrored ?? false;

	protected override async Task OnParametersSetAsync()
	{
		await base.OnParametersSetAsync();

		await ReloadPackage();
	}

	private async Task ReloadPackage() {
		Error = null;
		PackageModel = null;
		Editing = false;
		ShowUpstreamLink = false;

		if (PackageName is null) return;

		try
		{
			PackageModel = await Packages.GetPackage(PackageName, true, true);
		}
		catch (PackageNotFoundException pnfe)
		{
			Error = pnfe.Message;
			ShowUpstreamLink = true;

			return;
		}
		catch (Exception e)
		{
			Error = e.Message;

			return;
		}

		PackageVersion ??= PackageModel?.Latest?.Version;
		if (PackageVersion is not null)
		{
			try
			{
				PackageVersionModel = await Packages.GetPackageVersion(PackageName, PackageVersion);
			}
			catch (Exception e)
			{
				Error = e.Message;

				return;
			}
		}

		if (!IsMirrored)
		{
#pragma warning disable CS4014
			if (PackageModel?.Versions is not null)
				Task.WhenAll(PackageModel.Versions.OrderByDescending(v => v.Published).Take(10).Select(v => Analysis.GetAnalysisForVersion(PackageName, v.Version, false))).ContinueWith(_ => StateHasChanged());
#pragma warning restore CS4014
		}

		ShowPackageAdminTools = !IsMirrored && await Auth.IsSelf(PackageModel?.Author?.UserName);
	}

	private async Task OnDeleteVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to delete {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			await Packages.DeletePackageVersion(PackageName!, version);

			Info = $"Version {version} has been deleted.";

			await ReloadPackage();
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}

	private async Task OnRetractVersionClicked(string version)
	{
		var confirmed = await Alert.Confirm($"Are you sure you want to retract {PackageName}: {version}? This cannot be undone.");
		if (!confirmed)
			return;

		Info = null;
		Error = null;
		Editing = true;

		try
		{
			await Packages.RetractVersion(PackageName!, version);

			Info = $"Package version {version} has been marked as retracted.";

			await ReloadPackage();
		}
		catch (Exception e)
		{
			Error = e.Message;
		}
		finally
		{
			Editing = false;
		}
	}
}
