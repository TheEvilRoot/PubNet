@page "/package/{PackageName}"
@using System.Net
@using PubNet.API.DTO
@inject ApiClient Http
@inject AuthenticationService Auth
@inject NavigationManager Nav

@if (Error is not null)
{
    <div class="alert alert-danger">
        <strong>Whoops!</strong> @Error
    </div>
}

@if (PackageModel is null && Error is null)
{
    <PageTitle>@PackageName</PageTitle>

    <h1>@PackageName</h1>

    <p>
        <em>Loading...</em>
    </p>
}
else if (PackageModel is not null)
{
    @if (ShowPackageAdminTools)
    {
        <button class="btn btn-outline-danger my-3" @onclick="OnDeleteClicked" disabled="@Editing">Delete</button>
    }

    <p>
        Published by @if (PackageModel.Author is not null)
                     {
                         <NavLink href="@("/author/" + PackageModel.Author.UserName)">@PackageModel.Author.UserName</NavLink>
                     }
                     else
                     {
                         <span class="text-muted">&lt;deleted&gt;</span>
                     }
    </p>

    @if (PackageModel.Latest is null)
    {
        <PageTitle>@PackageName</PageTitle>

        <h1>@PackageName</h1>
    }
    else
    {
        <PageTitle>@PackageName @(PackageModel.Latest.Version)</PageTitle>

        <h1>@PackageName @(PackageModel.Latest.Version)</h1>

        <p>@(PackageModel.Latest.PubSpec?.Description)</p>

        @if (PackageModel.Latest.Analysis is {} analysis)
        {
            <div style="display: flex; align-items: center; gap: 0.25rem">
                @if (analysis.DocumentationHref is not null)
                {
                    <NavLink href="@(DocumentationUrl(analysis.DocumentationHref))" class="badge bg-info">Docs</NavLink>
                }

                @if (analysis.Formatted == true)
                {
                    <div class="badge bg-success">Formatted</div>
                }
                else if (analysis.Formatted == false)
                {
                    <div class="badge bg-warning">Not Formatted</div>
                }
            </div>
        }
        else
        {
            <div class="badge bg-secondary">Analysis not complete</div>
        }

        <h2 class="mt-4">Dependencies</h2>

        @if (PackageModel.Latest.PubSpec?.Dependencies is null || PackageModel.Latest.PubSpec?.Dependencies.Count == 0)
        {
            <p><em>No dependencies.</em></p>
        }
        else
        {
            <ul>
                @foreach (var dependency in PackageModel.Latest.PubSpec!.Dependencies!)
                {
                    <li><NavLink href="@LinkToDependency(dependency.Key)">@dependency.Key</NavLink></li>
                }
            </ul>
        }
    }

    @if (PackageModel.Versions is not null)
    {
        <h2>Versions</h2>

        <table class="table">
            <thead>
            <tr>
                <th>Version</th>
                <th>Published At</th>
                <th>Docs</th>
            </tr>
            </thead>
            <tbody>
            @foreach (var version in PackageModel.Versions.OrderByDescending(v => v.PublishedAt))
            {
                <tr>
                    <td>@version.Version</td>
                    <td>@version.PublishedAt</td>
                    <td>
                        @if (version.Analysis?.DocumentationHref is null)
                        {
                            <div class="badge bg-secondary">Analysis not complete</div>
                        }
                        else
                        {
                            <NavLink href="@(DocumentationUrl(version.Analysis.DocumentationHref))" class="badge bg-info">
                                Docs
                            </NavLink>
                        }
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }
    else
    {
        <p><em>No versions found.</em></p>
    }
}

@code
{
    [Parameter]
    public string? PackageName { get; set; }

    private PackageDto? PackageModel { get; set; }
    private string? Error { get; set; }
    
    private bool Editing { get; set; }
    private bool ShowPackageAdminTools { get; set; }

    private string DocumentationUrl(string uri) => Http.BaseAddress!.TrimEnd('/') + '/' + uri.TrimStart('/');

    private static string LinkToDependency(string name) => "/package/" + name;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        Error = null;

        try
        {
            var response = await Http.GetAsync($"packages/{PackageName}");
            if (response.IsSuccessStatusCode)
            {
                PackageModel = await response.Content.ReadFromJsonAsync<PackageDto>();
            }
            else
            {
                Error = response.StatusCode switch {
                    HttpStatusCode.NotFound => "The package you are looking for does not exist",
                    _ => "An unknown error occurred",
                };
            }

            ShowPackageAdminTools = PackageModel?.Author?.UserName is not null
                                    && await Auth.IsSelf(PackageModel.Author.UserName);
        }
        catch (Exception e)
        {
            Error = e.Message;
        }
    }

    private async Task OnDeleteClicked()
    {
        Error = null;
        Editing = true;

        try
        {
            var response = await Http.DeleteAsync($"packages/{PackageName}");
            if (response.IsSuccessStatusCode)
            {
                Nav.NavigateTo("/?message=package-deleted");
            }
            else
            {
                Error = response.StatusCode switch {
                    HttpStatusCode.Unauthorized => "You are not authorized to delete this package",
                    HttpStatusCode.NotFound => "The package was not found",
                    _ => "An unknown error occurred",
                };
            }
        }
        catch (Exception e)
        {
            Error = e.Message;
        }
        finally
        {
            Editing = false;
        }
    }
}
